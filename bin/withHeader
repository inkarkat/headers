#!/bin/bash

printUsage()
{
    cat <<HELPTEXT
If non-empty input is piped into this command, prepends HEADER before the
output. If there's no output, nothing is printed. Trailing empty lines at the
end of the input are omitted. An empty separator line is added before all
HEADERs (except the first one if --id ID (e.g. use PARENT-COMMAND-NAME-\$\$) is
passed to invocations of this command so that the sequence can be uniquely
identified).
HELPTEXT
    printf 'Usage: %q %s\n' "$(basename "$1")" '[--id ID] [--color=(always|auto|never)|--no-color] [--] HEADER [...] [-?|-h|--help]'
}

: ${HEADER_PREFIX=[01m}
: ${HEADER_SUFFIX=[0m}
typeset -a colorArg=()
isIdChange() { return 1; }
separator=$'\n'
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--id)		shift; passedId="$1"; shift
			isIdChange()
			{
			    readonly RUNTIME_DIRSPEC=${XDG_RUNTIME_DIR:?}/withHeader
			    [ -d "$RUNTIME_DIRSPEC" ] || mkdir -p -- "$RUNTIME_DIRSPEC" || { printf >&2 'ERROR: Could not initialize runtime store at %s!\n' "$RUNTIME_DIRSPEC"; exit 3; }
			    existingIdFilespec="${RUNTIME_DIRSPEC}/id"; existingId=; [ -r "$existingIdFilespec" ] && < "$existingIdFilespec" IFS=$' ' read -r existingId
			    if [ "$existingId" != "$passedId" ]; then
				# Omit separator on the first header associated with
				# ID, and store the ID to be able to recognize it on
				# subsequent calls.
				printf '%s\n' "$passedId" > "$existingIdFilespec"
				return 0
			    fi
			    return 1
			}
			;;
	--no-color|--color=*)	colorArg=("$1"); shift;;
	--color)		colorArg=("$1" "$2"); shift; shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -eq 0 ]; then
    printUsage "$0" >&2
    exit 2
fi
header="$*"
if ! isNeedColorArgumentWhenPiping "${colorArg[@]}"; then
    HEADER_PREFIX=
    HEADER_SUFFIX=
fi


# Consume first line(s) until we have a non-blank one; then we know that we need
# a header first.
buffer=
while IFS=$'\n' </dev/stdin read -r line
do
    buffer="${buffer}${line}
"
    if [ "$line" ]; then
	isIdChange && separator=
	printf "${separator}%s%s%s:\\n%s" "$HEADER_PREFIX" "$header" "$HEADER_SUFFIX" "$buffer"
	break
    fi
done

# Delete all trailing blank lines at the end of the input.
exec sed --unbuffered -e :a -e '/^\n*$/{$d; N; ba' -e '}'
